package b5oopB;

/**
 * @author Eva   Email:
 * @Description 重写
 * @data 2023/2/17 16:14
 */
public class BOverride extends AInheritance{
    /*
    1.重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作
    2.应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法
    3. 重写的规定:
	    方法的声明: 权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{
				//方法体
			}
		约定俗称: 子类中的叫重写的方法，父类中的叫被重写的方法
	1)子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
	2)子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
		>特殊情况:子类不能重写父类中声明为private权限的方法
	3)返回值类型:
		>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
		>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
		>父类被重写的方法的返回值类型是基本数据类型(比如，double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须，double)
	4）子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型(具体放到异常处理时候讲)

    *********************************************************
    子类和父类中的同名同参数的方法要么都声明为非static的(考虑重写)，要么都声明为static的 (不是重写）
    面试题，区分方法的重载与重写
     */

    @Override
    public String AA() {
        return "注意：权限修饰符、返回值（引用数据类型），不一致";
    }

    @Override
    int BB() throws RuntimeException{
        System.out.println("注意：返回值（基本数据类型），一致");
        System.out.println("抛出的异常不能超过父类");
        return 1;
    }

//    void CC(){}  // final会报错
}

    /*
    重写规则:
        1、参数列表必须完全相同
        2、返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
        3、访问权限不能比父类中被重写的方法的访问权限更低。
        4、声明为 final 的方法不能被重写
        5、声明为 static 的方法不能被重写，但是能够被再次声明。
        6、子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
        7、子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
        8、重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以
        9、构造方法不能被重写。
     */
